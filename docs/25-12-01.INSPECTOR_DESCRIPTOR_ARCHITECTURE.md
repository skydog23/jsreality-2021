# Inspector Descriptor Architecture (25-12-01)

## Goals
- Decouple inspector UI generation from DOM manipulation so apps/plugins describe controls declaratively.
- Reuse the same descriptor pipeline for built-in SceneGraphInspector sections and custom panels.
- Provide a catalog of widgets (number slider, toggle, color picker, enum selector, etc.) reusable across inspectors.
- Prepare for a SidePanelPlugin so inspectors mount cleanly beside the viewer.

## Current State (Baseline)
- **PropertySchemas**: hard-coded per-type definitions (`ComponentSchema`, `CameraSchema`, etc.). Each schema is consumed directly by `PropertyPanelManager` which builds DOM rows immediately.
- **WidgetFactory**: creates DOM widgets for primitive types (number, vector, color). Expectation: caller provides current value and change handler.
- **PropertyPanelManager**: iterates schema groups, calls `_addPropertyGroup`, and passes widgets/labels directly.
- **ShaderPropertyManager**: builds tree nodes + property sections manually; similar direct DOM generation.
- **SceneGraphInspector**: orchestrates managers, but callers (JSRApp) cannot inject extra descriptor sections without touching DOM.

## Problems with Current Approach
1. Schema layer not reusable: it emits DOM instructions rather than abstract descriptors.
2. WidgetFactory coupled to PropertyPanelManager; third-party plugins can’t reuse it easily.
3. No hook for app-specific inspector panels unless they manipulate DOM manually (JSRApp split-pane hack).
4. SidePanelPlugin not yet implemented, so inspector UI is special-cased.

## Proposed Descriptor Layer
### Descriptor Shape
- **Group**: `{ id, title, items: Descriptor[] }`
- **Descriptor** common fields:
  - `id`: stable identifier
  - `type`: e.g., `float`, `int`, `toggle`, `color`, `vec3`, `enum`, `text`, `button`
  - `label`: display label
  - `description` (optional): tooltip/help text
  - `getValue()`: returns current value
  - `setValue(value)`: applies new value (optional for read-only)
  - **Type-specific hints**:
    - `float/int`: `{ min, max, step }`
    - `enum`: `{ options: [{ value, label }] }`
    - `button`: `{ action: () => void, style }`
    - `color`: `{ format: 'rgb' | 'hex' }`
  - `disabled`, `hidden` flags as needed.

### Processing Flow
1. **Schemas** (built-in or custom) produce arrays of descriptors/group metadata instead of DOM.
2. **DescriptorRenderer** (new) takes descriptors → asks WidgetCatalog for corresponding widget component → handles layout (table, flex, etc.).
3. **WidgetCatalog** maps `type` → renderer; each renderer knows how to build DOM, wire events, and respect `disabled`, `min`, etc.
4. **InspectorHost** becomes the integration point: it accepts descriptor providers (functions that return descriptor groups for current selection) and hands them to DescriptorRenderer.

### Extensibility Hooks
- `registerInspectorSection({ id, label, match(node) => boolean, describe(node) => DescriptorGroup[] })`
- Custom inspectors (apps/plugins) call into InspectorHost/SceneGraphInspector to register descriptor providers.
- Descriptor providers can live in separate modules (e.g., `HeadlightControls`) and reuse the widget catalog.

## SidePanel Integration Plan
- Implement `SidePanelPlugin` (similar to `MenubarPlugin`) to manage viewer-adjacent panels.
- InspectorHost mounts inside a side panel rather than creating its own split pane.
- Custom descriptor-based panels can also register via SidePanelPlugin, ensuring consistent layout and lifecycle.

## Migration Strategy
1. **Phase 1 (this spec)**: document existing state + desired descriptor shape (done here).
2. **Phase 2**: update PropertySchemas/PropertyPanelManager to emit descriptors; introduce DescriptorRenderer; keep existing UI but via new pathway.
3. **Phase 3**: expose APIs for external descriptor providers; add SidePanelPlugin; refactor JSRApp to use it.
4. **Phase 4**: iterate widget catalog, add more control types, and document usage for app authors.

## Open Questions
- Should descriptors support async `getValue/setValue` (promises) for remote data? (Future consideration.)
- How to persist inspector state (expanded groups, widget layout) when descriptors are dynamic? Likely handled by DescriptorRenderer with stable IDs.
- How to package widget catalog so third-party code can import individual widgets? Possibly re-export them from `core/inspect/widgets`.

## Next Steps
- Approve descriptor shape & API.
- Implement DescriptorRenderer + schema adapters (Phase 2).
- Prototype a simple custom inspector (e.g., headlight controls) using descriptors to validate the flow before tackling SidePanelPlugin.

## Implementation Status (25-12-01)
- `DescriptorTypes`, `WidgetCatalog`, and `DescriptorRenderer` are now implemented under `src/core/inspect/descriptors/`.
- `PropertyPanelManager` has been refactored to emit descriptor groups for SceneGraphComponent, Transformation, Geometry, and Camera nodes while shader nodes still use the legacy DOM path.
- The new renderer reuses existing inspector CSS classes so the UI remains unchanged while enabling future descriptor-driven panels.
