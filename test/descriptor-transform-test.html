<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Descriptor Transformation Test</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: #1e1e1e;
        color: #e0e0e0;
        margin: 0;
        padding: 20px;
      }
      h1 {
        margin-top: 0;
      }
      #app {
        display: flex;
        gap: 24px;
      }
      #controls {
        width: 420px;
        background: #252526;
        border: 1px solid #333;
        border-radius: 6px;
        padding: 12px;
      }
      #matrix-view {
        flex: 1;
        background: #252526;
        border: 1px solid #333;
        border-radius: 6px;
        padding: 12px;
      }
      pre {
        background: #1a1a1a;
        padding: 12px;
        border-radius: 4px;
        overflow-x: auto;
      }
      button {
        background: #0e639c;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 3px;
        cursor: pointer;
        margin-right: 8px;
      }
      button:hover {
        background: #1177bb;
      }
      .sg-prop-group-body {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
    </style>
  </head>
  <body>
    <h1>Descriptor-Based Transformation Test</h1>
    <p>
      Change the translation, rotation, and scale descriptors to verify that a
      <code>FactoredMatrix</code> can be reconstructed reliably. The 4x4 matrix
      below should match the expected transformation values.
    </p>
    <div id="app">
      <div id="controls"></div>
      <div id="matrix-view">
        <div style="margin-bottom: 12px">
          <button id="reset">Reset</button>
          <button id="randomize">Randomize</button>
        </div>
        <h3>Matrix</h3>
        <pre id="matrix-output"></pre>
        <h3>Components</h3>
        <pre id="components-output"></pre>
      </div>
    </div>
    <script type="module">
      import { DescriptorRenderer } from '../src/core/inspect/descriptors/DescriptorRenderer.js';
      import { DescriptorType } from '../src/core/inspect/descriptors/DescriptorTypes.js';
      import { FactoredMatrix } from '../src/core/math/FactoredMatrix.js';
      import * as Pn from '../src/core/math/Pn.js';

      const identityMatrix = [
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
      ];

      const fm = new FactoredMatrix(Pn.EUCLIDEAN, identityMatrix);
      const renderer = new DescriptorRenderer(document.getElementById('controls'));
      renderer.render(buildTransformDescriptors());
      updateOutputs();

      document.getElementById('reset').addEventListener('click', () => {
        fm.setArray([...identityMatrix]);
        updateOutputs();
        renderer.render(buildTransformDescriptors());
      });

      document.getElementById('randomize').addEventListener('click', () => {
        const translation = [randInRange(-5, 5), randInRange(-5, 5), randInRange(-5, 5)];
        const scale = [randInRange(0.5, 2), randInRange(0.5, 2), randInRange(0.5, 2)];
        const axis = normalizeVector([Math.random(), Math.random(), Math.random()]);
        const angle = randInRange(-Math.PI, Math.PI);
        fm.setTranslation(...translation);
        fm.setStretchComponents(...scale);
        fm.setRotation(angle, axis);
        updateOutputs();
        renderer.render(buildTransformDescriptors());
      });

      function buildTransformDescriptors() {
        return [
          {
            id: 'position',
            title: 'Translation',
            items: [
              {
                id: 'translation',
                label: 'Position',
                type: DescriptorType.VECTOR,
                getValue: () => {
                  const t = fm.getTranslation();
                  return [t[0], t[1], t[2]];
                },
                setValue: (vec) => {
                  const [x = 0, y = 0, z = 0] = vec ?? [];
                  fm.setTranslation(x, y, z);
                  updateOutputs();
                }
              }
            ]
          },
          {
            id: 'rotation',
            title: 'Rotation',
            items: [
              {
                id: 'rotation-angle',
                label: 'Angle (Â°)',
                type: DescriptorType.FLOAT,
                min: -360,
                max: 360,
                step: 1,
                getValue: () => (fm.getRotationAngle() * 180) / Math.PI,
                setValue: (degrees) => {
                  const radians = Number(degrees) * Math.PI / 180;
                  fm.setRotation(radians, fm.getRotationAxis());
                  updateOutputs();
                }
              },
              {
                id: 'rotation-axis',
                label: 'Axis',
                type: DescriptorType.VECTOR,
                getValue: () => {
                  const axis = fm.getRotationAxis();
                  return [axis[0], axis[1], axis[2]];
                },
                setValue: (vec) => {
                  const axis = normalizeVector(vec ?? [0, 0, 1]);
                  fm.setRotation(fm.getRotationAngle(), axis);
                  updateOutputs();
                }
              }
            ]
          },
          {
            id: 'scale',
            title: 'Scale',
            items: [
              {
                id: 'scale-vector',
                label: 'Scale',
                type: DescriptorType.VECTOR,
                getValue: () => {
                  const s = fm.getStretch();
                  return [s[0], s[1], s[2]];
                },
                setValue: (vec) => {
                  const [sx = 1, sy = 1, sz = 1] = vec ?? [];
                  fm.setStretchComponents(sx, sy, sz);
                  updateOutputs();
                }
              }
            ]
          }
        ];
      }

      function updateOutputs() {
        const matrix = fm.getArray();
        document.getElementById('matrix-output').textContent = formatMatrix(matrix);
        const info = {
          translation: fm.getTranslation().slice(0, 3).map((v) => Number(v).toFixed(4)),
          rotationAxis: fm.getRotationAxis().map((v) => Number(v).toFixed(4)),
          rotationAngleDegrees: ((fm.getRotationAngle() * 180) / Math.PI).toFixed(4),
          scale: fm.getStretch().slice(0, 3).map((v) => Number(v).toFixed(4))
        };
        document.getElementById('components-output').textContent = JSON.stringify(info, null, 2);
      }

      function formatMatrix(array) {
        const rows = [];
        for (let i = 0; i < 4; i++) {
          rows.push(
            array
              .slice(i * 4, i * 4 + 4)
              .map((value) => Number(value).toFixed(6).padStart(12))
              .join(' ')
          );
        }
        return rows.join('\n');
      }

      function randInRange(min, max) {
        return Math.random() * (max - min) + min;
      }

      function normalizeVector(vec) {
        const [x = 0, y = 0, z = 1] = vec;
        const length = Math.hypot(x, y, z) || 1;
        return [x / length, y / length, z / length];
      }
    </script>
  </body>
</html>

