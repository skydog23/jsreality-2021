<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas2D Viewer with Inspector</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #1e1e1e;
            color: #cccccc;
        }
        
        .header {
            background: #2d2d2d;
            padding: 16px;
            border-bottom: 1px solid #3e3e3e;
        }
        
        .header h1 {
            margin: 0 0 8px 0;
            font-size: 24px;
            color: #ffffff;
        }
        
        .header p {
            margin: 0;
            color: #858585;
            font-size: 14px;
        }
        
        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        
        .canvas-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 300px;
        }
        
        .main-divider {
            width: 4px;
            background: #3e3e3e;
            cursor: ew-resize;
            flex-shrink: 0;
        }
        
        .main-divider:hover {
            background: #007acc;
        }
        
        .canvas-header {
            background: #2d2d2d;
            padding: 8px 12px;
            border-bottom: 1px solid #3e3e3e;
            font-weight: 600;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #252526;
            padding: 0;
            overflow: auto;
        }
        
        #canvas2d-test {
            border: 2px solid #3e3e3e;
            border-radius: 4px;
            background: white;
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
        }
        
        .inspector-panel {
            flex: 0 0 40%;
            display: flex;
            flex-direction: column;
            min-width: 300px;
        }
        
        .info {
            background: #2d2d2d;
            padding: 10px 12px;
            border-top: 1px solid #3e3e3e;
            font-family: monospace;
            font-size: 11px;
            max-height: 150px;
            overflow-y: auto;
            color: #858585;
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            margin: 20px;
            border-radius: 4px;
            border: 1px solid #f5c6cb;
        }
        
        /* Menubar styles */
        .menubar {
            background: #2d2d2d;
            border-bottom: 1px solid #3e3e3e;
            display: flex;
            padding: 0;
            font-size: 13px;
            user-select: none;
        }
        
        .menu-item {
            padding: 6px 12px;
            cursor: pointer;
            position: relative;
            color: #cccccc;
        }
        
        .menu-item:hover {
            background: #3e3e3e;
        }
        
        .menu-item.active {
            background: #094771;
        }
        
        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background: #2d2d2d;
            border: 1px solid #3e3e3e;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            min-width: 200px;
            display: none;
            z-index: 1000;
        }
        
        .dropdown-menu.show {
            display: block;
        }
        
        .menu-option {
            padding: 8px 16px;
            cursor: pointer;
            color: #cccccc;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .menu-option:hover {
            background: #094771;
        }
        
        .menu-option.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .menu-option.disabled:hover {
            background: transparent;
        }
        
        .menu-separator {
            height: 1px;
            background: #3e3e3e;
            margin: 4px 0;
        }
        
        .menu-shortcut {
            color: #858585;
            font-size: 11px;
            margin-left: 24px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîç Canvas2D Viewer with Scene Graph Inspector</h1>
        <p>Interactive viewer and inspector for exploring jSReality scene graphs</p>
    </div>
    
    <div class="menubar">
        <div class="menu-item" id="file-menu">
            File
            <div class="dropdown-menu" id="file-dropdown">
                <div class="menu-option" id="export-image-png">
                    <span>Export as PNG</span>
                </div>
                <div class="menu-option" id="export-image-jpeg">
                    <span>Export as JPEG</span>
                </div>
                <div class="menu-option" id="export-svg">
                    <span>Export as SVG</span>
                </div>
            </div>
        </div>
        <div class="menu-item" id="view-menu">
            View
            <div class="dropdown-menu" id="view-dropdown">
                <div class="menu-option" id="reset-camera">
                    <span>Reset Camera</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="main-container">
        <div class="canvas-panel" id="canvas-panel">
            <div class="canvas-header">Canvas Viewer</div>
            <div class="canvas-container">
                <canvas id="canvas2d-test"></canvas>
            </div>
            <div id="info-container" class="info"></div>
        </div>
        
        <div class="main-divider" id="main-divider"></div>
        
        <div class="inspector-panel" id="inspector-container"></div>
    </div>

    <div id="error-container"></div>

    <script type="module">
        import { runCanvas2DTest } from '../src/core/viewers/__tests__/Canvas2DViewerTest.js';
        import { SceneGraphInspector } from '../src/core/inspect/SceneGraphInspector.js';
        import { SVGViewer } from '../src/core/viewers/SVGViewer.js';
        
        // Setup resizable divider between canvas and inspector
        function setupMainDivider() {
            const divider = document.getElementById('main-divider');
            const canvasPanel = document.getElementById('canvas-panel');
            const inspectorPanel = document.getElementById('inspector-container');
            const mainContainer = document.querySelector('.main-container');
            
            let isDragging = false;
            let startX = 0;
            let startCanvasWidth = 0;
            
            divider.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startCanvasWidth = canvasPanel.offsetWidth;
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const delta = e.clientX - startX;
                const containerWidth = mainContainer.offsetWidth;
                const newCanvasWidth = startCanvasWidth + delta;
                const minWidth = 300; // Minimum panel width
                
                if (newCanvasWidth > minWidth && (containerWidth - newCanvasWidth) > minWidth) {
                    const percentage = (newCanvasWidth / containerWidth) * 100;
                    canvasPanel.style.flex = `0 0 ${percentage}%`;
                    inspectorPanel.style.flex = '1';
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        }
        
        // Setup menubar functionality
        function setupMenubar(viewer) {
            let activeMenu = null;
            
            // Close all menus
            function closeAllMenus() {
                document.querySelectorAll('.dropdown-menu').forEach(menu => {
                    menu.classList.remove('show');
                });
                document.querySelectorAll('.menu-item').forEach(item => {
                    item.classList.remove('active');
                });
                activeMenu = null;
            }
            
            // Toggle menu
            function toggleMenu(menuItem, dropdown) {
                const wasActive = dropdown.classList.contains('show');
                closeAllMenus();
                
                if (!wasActive) {
                    dropdown.classList.add('show');
                    menuItem.classList.add('active');
                    activeMenu = dropdown;
                }
            }
            
            // Setup File menu
            const fileMenu = document.getElementById('file-menu');
            const fileDropdown = document.getElementById('file-dropdown');
            
            fileMenu.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleMenu(fileMenu, fileDropdown);
            });
            
            // Setup View menu
            const viewMenu = document.getElementById('view-menu');
            const viewDropdown = document.getElementById('view-dropdown');
            
            viewMenu.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleMenu(viewMenu, viewDropdown);
            });
            
            // Export as PNG
            document.getElementById('export-image-png').addEventListener('click', () => {
                closeAllMenus();
                const dataURL = viewer.exportImage('image/png');
                downloadImage(dataURL, 'scene-export.png');
            });
            
            // Export as JPEG
            document.getElementById('export-image-jpeg').addEventListener('click', () => {
                closeAllMenus();
                const dataURL = viewer.exportImage('image/jpeg', 0.95);
                downloadImage(dataURL, 'scene-export.jpg');
            });
            
            // Export as SVG
            document.getElementById('export-svg').addEventListener('click', () => {
                closeAllMenus();
                
                // Get canvas dimensions
                const canvas = viewer.getViewingComponent();
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                
                // Create a temporary HTML container (doesn't need to be in DOM)
                const tempContainer = document.createElement('div');
                
                // Create SVGViewer with the container and dimensions
                const svgViewer = new SVGViewer(tempContainer, { width, height });
                
                // Copy scene setup from Canvas2DViewer
                svgViewer.setSceneRoot(viewer.getSceneRoot());
                svgViewer.setCameraPath(viewer.getCameraPath());
                
                // Render the scene to SVG
                svgViewer.render();
                
                // Export SVG as string
                const svgString = svgViewer.exportSVG();
                
                // Download SVG
                downloadSVG(svgString, 'scene-export.svg');
                
                console.log('‚úì SVG exported successfully');
            });
            
            // Reset camera (placeholder for now)
            document.getElementById('reset-camera').addEventListener('click', () => {
                closeAllMenus();
                console.log('Reset camera - not yet implemented');
                // TODO: Implement camera reset functionality
            });
            
            // Close menus when clicking outside
            document.addEventListener('click', (e) => {
                if (activeMenu && !e.target.closest('.menu-item')) {
                    closeAllMenus();
                }
            });
            
            // Helper function to download image
            function downloadImage(dataURL, filename) {
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                console.log(`‚úì Image exported as ${filename}`);
            }
            
            // Helper function to download SVG
            function downloadSVG(svgString, filename) {
                const blob = new Blob([svgString], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                console.log(`‚úì SVG exported as ${filename}`);
            }
        }
        
        try {
            // Run the test
            const viewer = runCanvas2DTest();
            
            // Add some extra debug info
            console.log('---');
            console.log('Canvas size:', viewer.getViewingComponentSize());
            console.log('Pixel ratio:', window.devicePixelRatio || 1);
            
            // Get the scene root from the viewer
            const sceneRoot = viewer.getSceneRoot();
            console.log('Scene root:', sceneRoot.getName());
            
            // Create and attach the inspector
            const inspectorContainer = document.getElementById('inspector-container');
            console.log('Inspector container:', inspectorContainer);
            console.log('Inspector container computed style:', window.getComputedStyle(inspectorContainer));
            const inspector = new SceneGraphInspector(inspectorContainer, sceneRoot);
            console.log('‚úì Scene Graph Inspector created');
            
            // Test: Verify tree view exists and is clickable
            setTimeout(() => {
              const treeView = inspectorContainer.querySelector('.sg-tree-view');
              console.log('Tree view element:', treeView);
              console.log('Tree view computed style:', treeView ? window.getComputedStyle(treeView) : 'NOT FOUND');
              if (treeView) {
                console.log('Tree view children count:', treeView.children.length);
                // Check if expand icons exist and have handlers
                const expandIcons = treeView.querySelectorAll('.sg-tree-expand');
                console.log('Found expand icons:', expandIcons.length);
                expandIcons.forEach((icon, i) => {
                  console.log(`Expand icon ${i}:`, icon, 'text:', icon.textContent);
                });
                // Add a test click listener directly to the tree view (bubble phase, fires AFTER individual handlers)
                treeView.addEventListener('click', (e) => {
                  console.log('Tree view clicked!', e.target, e.target.className, e.target.tagName);
                  // Check if target is a header or expand icon
                  const header = e.target.closest('.sg-tree-node-header');
                  const expand = e.target.closest('.sg-tree-expand');
                  console.log('Closest header:', header);
                  console.log('Closest expand:', expand);
                  if (expand) {
                    console.log('Expand icon found via closest!');
                  }
                }, false); // Use bubble phase - fires AFTER individual handlers
              }
            }, 100);
            
            // Store viewer reference globally so inspector changes can trigger renders
            window._viewerInstance = viewer;
            
            // Auto-expand the root node for convenience
            inspector.refresh();
            
            // Add a hook to refresh inspector when viewer renders
            // NOTE: Commented out because constant refresh might interfere with click handling
            // Uncomment if you need live updates, but be aware it rebuilds the tree on every render
            // const originalRender = viewer.render.bind(viewer);
            // viewer.render = function() {
            //     originalRender();
            //     inspector.refresh();
            // };
            
            console.log('‚úì Inspector integrated with viewer');
            console.log('‚úì You can now edit appearance attributes and see changes in real-time!');
            
            // Setup resizable main divider
            setupMainDivider();
            
            // Setup menubar
            setupMenubar(viewer);
            console.log('‚úì Menubar initialized');
            
            // Add a test to verify console.log is working
            window.testConsole = function() {
                console.log('TEST: Console.log is working!', new Date().toISOString());
            };
            console.log('TIP: Type testConsole() in console to verify logging works');
            
            // Add direct visibility toggle test
            window.toggleGridVisibility = function() {
                const children = sceneRoot.getChildComponents();
                const grid = children.find(c => c.getName() === 'grid');
                if (grid) {
                    const newVis = !grid.isVisible();
                    console.log('BEFORE: grid visibility =', grid.isVisible());
                    grid.setVisible(newVis);
                    console.log('AFTER: grid visibility =', grid.isVisible());
                    viewer.render();
                    console.log('Render called');
                } else {
                    console.log('Grid component not found');
                }
            };
            console.log('TIP: Type toggleGridVisibility() to test visibility programmatically');
            
        } catch (error) {
            console.error('Test failed:', error);
            const errorContainer = document.getElementById('error-container');
            errorContainer.innerHTML = `
                <div class="error">
                    <h4>Test Failed</h4>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <pre>${error.stack}</pre>
                </div>
            `;
        }
    </script>
</body>
</html>

