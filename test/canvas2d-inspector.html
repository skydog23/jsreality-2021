<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas2D Viewer with Inspector</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #1e1e1e;
            color: #cccccc;
        }
        
        .header {
            background: #2d2d2d;
            padding: 16px;
            border-bottom: 1px solid #3e3e3e;
        }
        
        .header h1 {
            margin: 0 0 8px 0;
            font-size: 24px;
            color: #ffffff;
        }
        
        .header p {
            margin: 0;
            color: #858585;
            font-size: 14px;
        }
        
        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        
        .canvas-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 300px;
        }
        
        .main-divider {
            width: 4px;
            background: #3e3e3e;
            cursor: ew-resize;
            flex-shrink: 0;
        }
        
        .main-divider:hover {
            background: #007acc;
        }
        
        .canvas-header {
            background: #2d2d2d;
            padding: 8px 12px;
            border-bottom: 1px solid #3e3e3e;
            font-weight: 600;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #252526;
            padding: 0;
            overflow: auto;
        }
        
        #canvas2d-test,
        #webgl2d-test {
            border: 2px solid #3e3e3e;
            border-radius: 4px;
            background: white;
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
        }
        
        #svg2d-test {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
        }
        
        .inspector-panel {
            flex: 0 0 40%;
            display: flex;
            flex-direction: column;
            min-width: 300px;
        }
        
        .info {
            background: #2d2d2d;
            padding: 10px 12px;
            border-top: 1px solid #3e3e3e;
            font-family: monospace;
            font-size: 11px;
            max-height: 150px;
            overflow-y: auto;
            color: #858585;
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            margin: 20px;
            border-radius: 4px;
            border: 1px solid #f5c6cb;
        }
        
        /* Menubar styles */
        .menubar {
            background: #2d2d2d;
            border-bottom: 1px solid #3e3e3e;
            display: flex;
            padding: 0;
            font-size: 13px;
            user-select: none;
        }
        
        .menu-item {
            padding: 6px 12px;
            cursor: pointer;
            position: relative;
            color: #cccccc;
        }
        
        .menu-item:hover {
            background: #3e3e3e;
        }
        
        .menu-item.active {
            background: #094771;
        }
        
        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background: #2d2d2d;
            border: 1px solid #3e3e3e;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            min-width: 200px;
            display: none;
            z-index: 1000;
        }
        
        .dropdown-menu.show {
            display: block;
        }
        
        .menu-option {
            padding: 8px 16px;
            cursor: pointer;
            color: #cccccc;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .menu-option:hover {
            background: #094771;
        }
        
        .menu-option.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .menu-option.disabled:hover {
            background: transparent;
        }
        
        .menu-separator {
            height: 1px;
            background: #3e3e3e;
            margin: 4px 0;
        }
        
        .menu-shortcut {
            color: #858585;
            font-size: 11px;
            margin-left: 24px;
        }
        
        .menu-radio-group {
            font-weight: 600;
            color: #858585;
            padding: 8px 16px 4px 16px;
        }
        
        .menu-radio-option {
            padding: 4px 16px;
        }
        
        .menu-radio-option label {
            display: flex;
            align-items: center;
            cursor: pointer;
            width: 100%;
            margin: 0;
        }
        
        .menu-radio-option input[type="radio"] {
            margin-right: 8px;
            cursor: pointer;
        }
        
        .menu-radio-option:hover {
            background: #094771;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîç Canvas2D Viewer with Scene Graph Inspector</h1>
        <p>Interactive viewer and inspector for exploring jSReality scene graphs</p>
    </div>
    
    <div class="menubar">
        <div class="menu-item" id="file-menu">
            File
            <div class="dropdown-menu" id="file-dropdown">
                <div class="menu-option" id="export-image-png">
                    <span>Export as PNG</span>
                </div>
                <div class="menu-option" id="export-image-jpeg">
                    <span>Export as JPEG</span>
                </div>
                <div class="menu-option" id="export-svg">
                    <span>Export as SVG</span>
                </div>
                <div class="menu-option" id="export-webgl">
                    <span>Export WebGL</span>
                </div>
            </div>
        </div>
        <div class="menu-item" id="view-menu">
            View
            <div class="dropdown-menu" id="view-dropdown">
                <div class="menu-option menu-radio-group">
                    <span>Renderer:</span>
                </div>
                <div class="menu-option menu-radio-option" data-viewer-index="0">
                    <label>
                        <input type="radio" name="viewer-select" value="0" checked>
                        <span>Canvas2D</span>
                    </label>
                </div>
                <div class="menu-option menu-radio-option" data-viewer-index="1">
                    <label>
                        <input type="radio" name="viewer-select" value="1">
                        <span>WebGL2</span>
                    </label>
                </div>
                <div class="menu-option menu-radio-option" data-viewer-index="2">
                    <label>
                        <input type="radio" name="viewer-select" value="2">
                        <span>SVG</span>
                    </label>
                </div>
                <div class="menu-separator"></div>
                <div class="menu-option" id="reset-camera">
                    <span>Reset Camera</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="main-container">
        <div class="canvas-panel" id="canvas-panel">
            <div class="canvas-header">Canvas Viewer</div>
            <div class="canvas-container">
                <canvas id="canvas2d-test"></canvas>
                <canvas id="webgl2d-test" style="display: none;"></canvas>
                <div id="svg2d-test" style="display: none;"></div>
            </div>
            <div id="info-container" class="info"></div>
        </div>
        
        <div class="main-divider" id="main-divider"></div>
        
        <div class="inspector-panel" id="inspector-container"></div>
    </div>

    <div id="error-container"></div>

    <script type="module">
        import { runCanvas2DTest, createTestScene, getDoAnimation, setDoAnimation } from '../src/core/viewers/__tests__/Canvas2DViewerTest.js';
        import { SceneGraphInspector } from '../src/core/inspect/SceneGraphInspector.js';
        import { SVGViewer } from '../src/core/viewers/SVGViewer.js';
        import { WebGL2Viewer } from '../src/core/viewers/WebGL2Viewer.js';
        import { Canvas2DViewer } from '../src/core/viewers/Canvas2DViewer.js';
        import { MatrixBuilder } from '../src/core/math/MatrixBuilder.js';
        import { toDataList, fromDataList } from '../src/core/scene/data/DataUtility.js';
        import { GeometryAttribute } from '../src/core/scene/GeometryAttribute.js';
        import * as Rn from '../src/core/math/Rn.js';
        
        // Setup resizable divider between canvas and inspector
        function setupMainDivider() {
            const divider = document.getElementById('main-divider');
            const canvasPanel = document.getElementById('canvas-panel');
            const inspectorPanel = document.getElementById('inspector-container');
            const mainContainer = document.querySelector('.main-container');
            
            let isDragging = false;
            let startX = 0;
            let startCanvasWidth = 0;
            
            divider.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startCanvasWidth = canvasPanel.offsetWidth;
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const delta = e.clientX - startX;
                const containerWidth = mainContainer.offsetWidth;
                const newCanvasWidth = startCanvasWidth + delta;
                const minWidth = 300; // Minimum panel width
                
                if (newCanvasWidth > minWidth && (containerWidth - newCanvasWidth) > minWidth) {
                    const percentage = (newCanvasWidth / containerWidth) * 100;
                    canvasPanel.style.flex = `0 0 ${percentage}%`;
                    inspectorPanel.style.flex = '1';
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        }
        
        // Setup menubar functionality
        // viewerGetter: function that returns the current viewer (updates when cycling)
        function setupMenubar(viewerGetter, cycleViewerCallback) {
            let activeMenu = null;
            
            // Close all menus
            function closeAllMenus() {
                document.querySelectorAll('.dropdown-menu').forEach(menu => {
                    menu.classList.remove('show');
                });
                document.querySelectorAll('.menu-item').forEach(item => {
                    item.classList.remove('active');
                });
                activeMenu = null;
            }
            
            // Toggle menu
            function toggleMenu(menuItem, dropdown) {
                const wasActive = dropdown.classList.contains('show');
                closeAllMenus();
                
                if (!wasActive) {
                    dropdown.classList.add('show');
                    menuItem.classList.add('active');
                    activeMenu = dropdown;
                }
            }
            
            // Setup File menu
            const fileMenu = document.getElementById('file-menu');
            const fileDropdown = document.getElementById('file-dropdown');
            
            fileMenu.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleMenu(fileMenu, fileDropdown);
            });
            
            // Setup View menu
            const viewMenu = document.getElementById('view-menu');
            const viewDropdown = document.getElementById('view-dropdown');
            
            viewMenu.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleMenu(viewMenu, viewDropdown);
            });
            
            // Viewer selection radio buttons will be set up after switchViewer is defined
            // This is handled in the main initialization code below
            
            // Export as PNG
            document.getElementById('export-image-png').addEventListener('click', () => {
                closeAllMenus();
                const viewer = viewerGetter();
                // Use current viewer, but only if it supports exportImage
                if (viewer && viewer.exportImage) {
                    const dataURL = viewer.exportImage('image/png');
                    downloadImage(dataURL, 'scene-export.png');
                } else {
                    alert('Current viewer does not support PNG export');
                }
            });
            
            // Export as JPEG
            document.getElementById('export-image-jpeg').addEventListener('click', () => {
                closeAllMenus();
                const viewer = viewerGetter();
                // Use current viewer, but only if it supports exportImage
                if (viewer && viewer.exportImage) {
                    const dataURL = viewer.exportImage('image/jpeg', 0.95);
                    downloadImage(dataURL, 'scene-export.jpg');
                } else {
                    alert('Current viewer does not support JPEG export');
                }
            });
            
            // Export as SVG
            document.getElementById('export-svg').addEventListener('click', () => {
                closeAllMenus();
                const viewer = viewerGetter();
                
                // Get canvas dimensions from current viewer
                const viewingComponent = viewer.getViewingComponent();
                const width = viewingComponent.clientWidth || viewingComponent.offsetWidth;
                const height = viewingComponent.clientHeight || viewingComponent.offsetHeight;
                
                // Create a temporary HTML container with explicit dimensions
                const tempContainer = document.createElement('div');
                tempContainer.style.width = `${width}px`;
                tempContainer.style.height = `${height}px`;
                
                // Create SVGViewer - dimensions will be read from container
                const svgViewer = new SVGViewer(tempContainer);
                
                // Copy scene setup from current viewer
                svgViewer.setSceneRoot(viewer.getSceneRoot());
                svgViewer.setCameraPath(viewer.getCameraPath());
                
                // Render the scene to SVG
                svgViewer.render();
                
                // Export SVG as string
                const svgString = svgViewer.exportSVG();
                
                // Download SVG
                downloadSVG(svgString, 'scene-export.svg');
                
                console.log('‚úì SVG exported successfully');
            });
            
            // Export WebGL with anti-aliasing (2x supersampling)
            document.getElementById('export-webgl').addEventListener('click', () => {
                closeAllMenus();
                const viewer = viewerGetter();
                
                try {
                    // Get canvas dimensions from current viewer
                    const viewingComponent = viewer.getViewingComponent();
                    const width = viewingComponent.clientWidth || viewingComponent.offsetWidth;
                    const height = viewingComponent.clientHeight || viewingComponent.offsetHeight;
                    
                    // Anti-aliasing: render at 4x resolution, then scale down by factor of 2
                    // Result: 2x canvas size with anti-aliasing
                    const renderScaleFactor = 4; // Render at 4x resolution
                    const outputScaleFactor = 2; // Output at 2x canvas size
                    const renderWidth = width * renderScaleFactor;
                    const renderHeight = height * renderScaleFactor;
                    const outputWidth = width * outputScaleFactor;
                    const outputHeight = height * outputScaleFactor;
                    
                    // Create a temporary canvas for WebGL rendering at 4x resolution
                    const webglCanvas = document.createElement('canvas');
                    // Set CSS dimensions to original size (WebGL2Viewer will multiply by pixelRatio)
                    webglCanvas.style.width = width + 'px';
                    webglCanvas.style.height = height + 'px';
                    // Temporarily add to DOM so clientWidth/clientHeight are available
                    webglCanvas.style.position = 'absolute';
                    webglCanvas.style.left = '-9999px';
                    document.body.appendChild(webglCanvas);
                    
                    try {
                        // Create WebGL2Viewer with pixelRatio=4 to render at 4x resolution
                        // CSS size is 1x, pixelRatio is 4x, so canvas.width = width * 4 = renderWidth
                        const webglViewer = new WebGL2Viewer(webglCanvas, {
                            preserveDrawingBuffer: true,
                            autoResize: false, // Don't auto-resize since we're setting dimensions manually
                            pixelRatio: renderScaleFactor // Use 4x pixel ratio for supersampling
                        });
                    
                        // Copy scene setup from current viewer
                        webglViewer.setSceneRoot(viewer.getSceneRoot());
                        webglViewer.setCameraPath(viewer.getCameraPath());
                        
                        // Render the scene to WebGL at 4x resolution
                        webglViewer.render();
                        
                        // Small delay to ensure rendering completes
                        setTimeout(() => {
                            // Verify actual canvas dimensions after WebGL setup
                            const actualWidth = webglCanvas.width;
                            const actualHeight = webglCanvas.height;
                            console.log('WebGL canvas actual size (4x):', actualWidth, 'x', actualHeight);
                            console.log('Output size (2x canvas):', outputWidth, 'x', outputHeight);
                            
                            // Create a temporary canvas at 2x resolution for downscaling
                            const outputCanvas = document.createElement('canvas');
                            outputCanvas.width = outputWidth;
                            outputCanvas.height = outputHeight;
                            const ctx = outputCanvas.getContext('2d');
                            
                            // Enable smooth scaling for better anti-aliasing
                            ctx.imageSmoothingEnabled = true;
                            ctx.imageSmoothingQuality = 'high';
                            
                            // Scale down the 4x resolution WebGL canvas to 2x canvas size
                            // This provides anti-aliasing through supersampling (4x ‚Üí 2x = 2x downscale)
                            // Use actual canvas dimensions
                            ctx.drawImage(webglCanvas, 0, 0, actualWidth, actualHeight, 0, 0, outputWidth, outputHeight);
                            
                            // Export the downscaled canvas as PNG
                            const dataURL = outputCanvas.toDataURL('image/png');
                            if (dataURL && dataURL !== 'data:,') {
                                downloadImage(dataURL, 'scene-export-webgl.png');
                                console.log('‚úì WebGL exported successfully: 4x render ‚Üí 2x output with anti-aliasing, dataURL length:', dataURL.length);
                            } else {
                                console.error('Output canvas appears to be empty');
                                alert('Failed to export WebGL: Canvas appears to be empty. Check console for errors.');
                            }
                            
                            // Clean up temporary canvases
                            document.body.removeChild(webglCanvas);
                        }, 100);
                    } catch (error) {
                        console.error('Error exporting WebGL:', error);
                        alert('Failed to export WebGL: ' + error.message);
                        // Clean up temporary canvas on error
                        if (webglCanvas.parentNode) {
                            document.body.removeChild(webglCanvas);
                        }
                    }
                } catch (error) {
                    console.error('Error setting up WebGL export:', error);
                    alert('Failed to export WebGL: ' + error.message);
                }
            });
            
            // Reset camera (placeholder for now)
            document.getElementById('reset-camera').addEventListener('click', () => {
                closeAllMenus();
                console.log('Reset camera - not yet implemented');
                // TODO: Implement camera reset functionality
            });
            
            // Close menus when clicking outside
            document.addEventListener('click', (e) => {
                if (activeMenu && !e.target.closest('.menu-item')) {
                    closeAllMenus();
                }
            });
            
            // Helper function to download image
            function downloadImage(dataURL, filename) {
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                console.log(`‚úì Image exported as ${filename}`);
            }
            
            // Helper function to download SVG
            function downloadSVG(svgString, filename) {
                const blob = new Blob([svgString], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                console.log(`‚úì SVG exported as ${filename}`);
            }
        }
        
        try {
            // Create test scene (reuse logic from runCanvas2DTest)
            // We'll create the scene separately and then create all viewers
            const canvas = document.getElementById('canvas2d-test');
            const webglCanvas = document.getElementById('webgl2d-test');
            const svgContainer = document.getElementById('svg2d-test');
            
            // Create the test scene directly (without running the test which starts animation)
            const { sceneRoot, cameraPath, worldSGC } = createTestScene();
            console.log('‚úì Test scene created');
            
            // Now create all 3 viewers with the same scene
            const canvasViewer = new Canvas2DViewer(canvas);
            canvasViewer.setSceneRoot(sceneRoot);
            canvasViewer.setCameraPath(cameraPath);
            canvasViewer.render();
            
            const webglViewer = new WebGL2Viewer(webglCanvas);
            webglViewer.setSceneRoot(sceneRoot);
            webglViewer.setCameraPath(cameraPath);
            webglViewer.render();
            
            console.log('Creating SVGViewer - dimensions will auto-size from container');
            
            const svgViewer = new SVGViewer(svgContainer);
            svgViewer.setSceneRoot(sceneRoot);
            svgViewer.setCameraPath(cameraPath);
            svgViewer.render();
            
            // Create viewers array and set current viewer
            const viewers = [canvasViewer, webglViewer, svgViewer];
            const viewerNames = ['Canvas2D', 'WebGL2', 'SVG'];
            let currentViewerIndex = 0;
            let currentViewer = viewers[currentViewerIndex];
            
            // Function to switch to a specific viewer
            function switchViewer(index) {
                // Hide all viewing components
                canvas.style.display = 'none';
                webglCanvas.style.display = 'none';
                svgContainer.style.display = 'none';
                
                // Show the selected viewer's component
                currentViewerIndex = index;
                currentViewer = viewers[currentViewerIndex];
                
                if (currentViewer === canvasViewer) {
                    canvas.style.display = 'block';
                } else if (currentViewer === webglViewer) {
                    webglCanvas.style.display = 'block';
                } else if (currentViewer === svgViewer) {
                    svgContainer.style.display = 'block';
                    // SVG viewer needs container dimensions - update SVG element directly
                    const svgElement = svgViewer.getViewingComponent();
                    // Get dimensions from canvas container (which should be properly sized)
                    const canvasContainer = canvas.parentElement;
                    const width = canvas.clientWidth || canvas.offsetWidth || canvasContainer.clientWidth || 800;
                    const height = canvas.clientHeight || canvas.offsetHeight || canvasContainer.clientHeight || 600;
                    console.log('Updating SVGViewer dimensions to:', width, 'x', height);
                    svgElement.setAttribute('width', width);
                    svgElement.setAttribute('height', height);
                    svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
                }
                
                // Re-render with the new viewer (use async to avoid blocking click handler)
                // This prevents performance violations when rendering complex scenes
                currentViewer.renderAsync();
                
                console.log(`‚úì Switched to ${viewerNames[currentViewerIndex]} viewer`);
            }
            
            // Initialize: show Canvas2D viewer
            switchViewer(0);
            
            // Setup viewer selection radio buttons
            const viewerRadios = document.querySelectorAll('input[name="viewer-select"]');
            viewerRadios.forEach((radio) => {
                radio.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        const viewerIndex = parseInt(e.target.value);
                        // Close menu when selection changes
                        document.querySelectorAll('.dropdown-menu').forEach(menu => {
                            menu.classList.remove('show');
                        });
                        document.querySelectorAll('.menu-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        switchViewer(viewerIndex);
                    }
                });
            });
            
            // Setup animation for the icosahedron (same as in Canvas2DViewerTest)
            // Animation state is controlled via getDoAnimation/setDoAnimation from Canvas2DViewerTest
            let animationStartTime = null;
            
            // Select the misc component to animate (index 6 is the icosahedron)
            const animatedGeometry = worldSGC.getChildComponent(6).getGeometry();
            const icoverts = fromDataList(animatedGeometry.getVertexAttribute(GeometryAttribute.COORDINATES));
            
            // Performance profiling: enable to see detailed timing in DevTools Performance tab
            const ENABLE_PROFILING = true;
            
            function animate(timestamp) {
                if (!getDoAnimation()) return; // Early exit if animation is disabled
                
                if (ENABLE_PROFILING) {
                    performance.mark('animate-start');
                }
                
                // Initialize start time on first call
                if (animationStartTime === null) {
                    animationStartTime = timestamp;
                }
                
                // Calculate elapsed time in seconds
                const elapsedSeconds = (timestamp - animationStartTime) / 1000;
                
                if (ENABLE_PROFILING) {
                    performance.mark('matrix-build-start');
                }
                
                // Apply rotation transformation (rotating around Y-axis)
                const rotationAngle = elapsedSeconds * Math.PI * 0.125; // Rotate at 0.5 rad/s
                const matrix = MatrixBuilder.euclidean()
                    .rotateY(rotationAngle)
                    .getArray();
                
                if (ENABLE_PROFILING) {
                    performance.mark('matrix-build-end');
                    performance.mark('transform-vertices-start');
                }
                
                const transformedIcoverts = Rn.matrixTimesVectorArray(null, matrix, icoverts);
                
                if (ENABLE_PROFILING) {
                    performance.mark('transform-vertices-end');
                    performance.mark('update-geometry-start');
                }
                
                // Use setVertexAttribute instead of setVertexCoordinates to avoid updating vertex count
                const coordList = toDataList(transformedIcoverts);
                animatedGeometry.setVertexAttribute(GeometryAttribute.COORDINATES, coordList);
                
                if (ENABLE_PROFILING) {
                    performance.mark('update-geometry-end');
                    performance.mark('render-start');
                }
                
                // Render using the CURRENT viewer (not hardcoded)
                currentViewer.render();
                
                if (ENABLE_PROFILING) {
                    performance.mark('render-end');
                    performance.mark('animate-end');
                    
                    // Create measurements for DevTools Performance panel
                    performance.measure('matrix-build', 'matrix-build-start', 'matrix-build-end');
                    performance.measure('transform-vertices', 'transform-vertices-start', 'transform-vertices-end');
                    performance.measure('update-geometry', 'update-geometry-start', 'update-geometry-end');
                    performance.measure('render', 'render-start', 'render-end');
                    performance.measure('total-frame', 'animate-start', 'animate-end');
                    
                    // Log frame time occasionally (every 60 frames ~= once per second at 60fps)
                    if (Math.floor(elapsedSeconds * 60) % 60 === 0 && Math.floor(elapsedSeconds * 60) > 0) {
                        const measures = performance.getEntriesByType('measure');
                        const lastFrame = measures.filter(m => m.name === 'total-frame').slice(-1)[0];
                        if (lastFrame) {
                            console.log(`[${viewerNames[currentViewerIndex]}] Frame time: ${lastFrame.duration.toFixed(2)}ms`);
                        }
                    }
                }
                
                // Schedule next frame
                if (getDoAnimation()) {
                    requestAnimationFrame(animate);
                }
            }
            
            // Start animation after a short delay (only if enabled)
            if (getDoAnimation()) {
                setTimeout(() => {
                    console.log('‚úì Starting animation using requestAnimationFrame');
                    animationStartTime = null; // Reset for clean start
                    requestAnimationFrame(animate);
                }, 1500);
            } else {
                console.log('Animation disabled (use setDoAnimation(true) to enable)');
            }
            
            // Add some extra debug info
            console.log('---');
            console.log('Canvas size:', currentViewer.getViewingComponentSize());
            console.log('Pixel ratio:', window.devicePixelRatio || 1);
            console.log('Scene root:', sceneRoot.getName());
            console.log('‚úì All 3 viewers created and initialized');
            
            // Create and attach the inspector
            const inspectorContainer = document.getElementById('inspector-container');
            const inspector = new SceneGraphInspector(inspectorContainer, sceneRoot);
            console.log('‚úì Scene Graph Inspector created');
            
            // Store current viewer reference globally so inspector changes can trigger renders
            window._viewerInstance = currentViewer;
            
            // Expose switchViewer globally for radio button handlers
            window._switchViewer = switchViewer;
            
            // Update switchViewer to sync radio buttons and inspector reference
            const originalSwitchViewer = switchViewer;
            switchViewer = function(index) {
                originalSwitchViewer(index);
                // Update radio button to match current viewer
                const radios = document.querySelectorAll('input[name="viewer-select"]');
                if (radios[index]) {
                    radios[index].checked = true;
                }
                // Update inspector's viewer reference
                window._viewerInstance = currentViewer;
            };
            
            // Auto-expand the root node for convenience
            inspector.refresh();
            
            console.log('‚úì Inspector integrated with viewer');
            console.log('‚úì You can now edit appearance attributes and see changes in real-time!');
            
            // Setup resizable main divider
            setupMainDivider();
            
            // Setup menubar (pass getter function for current viewer)
            setupMenubar(() => currentViewer, null);
            console.log('‚úì Menubar initialized');
            
            // Add a test to verify console.log is working
            window.testConsole = function() {
                console.log('TEST: Console.log is working!', new Date().toISOString());
            };
            console.log('TIP: Type testConsole() in console to verify logging works');
            
            // Add direct visibility toggle test
            window.toggleGridVisibility = function() {
                const children = sceneRoot.getChildComponents();
                const grid = children.find(c => c.getName() === 'grid');
                if (grid) {
                    const newVis = !grid.isVisible();
                    console.log('BEFORE: grid visibility =', grid.isVisible());
                    grid.setVisible(newVis);
                    console.log('AFTER: grid visibility =', grid.isVisible());
                    currentViewer.render();
                    console.log('Render called');
                } else {
                    console.log('Grid component not found');
                }
            };
            console.log('TIP: Type toggleGridVisibility() to test visibility programmatically');
            
        } catch (error) {
            console.error('Test failed:', error);
            const errorContainer = document.getElementById('error-container');
            errorContainer.innerHTML = `
                <div class="error">
                    <h4>Test Failed</h4>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <pre>${error.stack}</pre>
                </div>
            `;
        }
    </script>
</body>
</html>

